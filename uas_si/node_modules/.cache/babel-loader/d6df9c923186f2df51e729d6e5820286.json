{"ast":null,"code":"'use strict';\n\nvar firebase = require('@firebase/app');\n\nvar component = require('@firebase/component');\n\nvar tslib = require('tslib');\n\nvar util = require('@firebase/util');\n\nvar logger$1 = require('@firebase/logger');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar firebase__default = /*#__PURE__*/_interopDefaultLegacy(firebase);\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar _a;\n\nvar ERRORS = (_a = {}, _a[\"already-activated\"\n/* ALREADY_ACTIVATED */\n] = 'You are trying to activate AppCheck for FirebaseApp {$appName}, ' + 'while it is already activated. ' + 'AppCheck can only be activated once.', _a[\"use-before-activation\"\n/* USE_BEFORE_ACTIVATION */\n] = 'AppCheck is being used before activate() is called for FirebaseApp {$appName}. ' + 'Please make sure you call activate() before instantiating other Firebase services.', _a[\"fetch-network-error\"\n/* FETCH_NETWORK_ERROR */\n] = 'Fetch failed to connect to a network. Check Internet connection. ' + 'Original error: {$originalErrorMessage}.', _a[\"fetch-parse-error\"\n/* FETCH_PARSE_ERROR */\n] = 'Fetch client could not parse response.' + ' Original error: {$originalErrorMessage}.', _a[\"fetch-status-error\"\n/* FETCH_STATUS_ERROR */\n] = 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.', _a[\"storage-open\"\n/* STORAGE_OPEN */\n] = 'Error thrown when opening storage. Original error: {$originalErrorMessage}.', _a[\"storage-get\"\n/* STORAGE_GET */\n] = 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.', _a[\"storage-set\"\n/* STORAGE_WRITE */\n] = 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.', _a[\"recaptcha-error\"\n/* RECAPTCHA_ERROR */\n] = 'ReCAPTCHA error.', _a);\nvar ERROR_FACTORY = new util.ErrorFactory('appCheck', 'AppCheck', ERRORS);\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar APP_CHECK_STATES = new Map();\nvar DEFAULT_STATE = {\n  activated: false,\n  tokenListeners: []\n};\nvar DEBUG_STATE = {\n  enabled: false\n};\n\nfunction getState(app) {\n  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;\n}\n\nfunction setState(app, state) {\n  APP_CHECK_STATES.set(app, state);\n}\n\nfunction getDebugState() {\n  return DEBUG_STATE;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction getRecaptcha() {\n  return self.grecaptcha;\n}\n\nfunction ensureActivated(app) {\n  if (!getState(app).activated) {\n    throw ERROR_FACTORY.create(\"use-before-activation\"\n    /* USE_BEFORE_ACTIVATION */\n    , {\n      appName: app.name\n    });\n  }\n}\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n */\n\n\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\n\nfunction initialize(app, siteKey) {\n  var state = getState(app);\n  var initialized = new util.Deferred();\n  setState(app, tslib.__assign(tslib.__assign({}, state), {\n    reCAPTCHAState: {\n      initialized: initialized\n    }\n  }));\n  var divId = \"fire_app_check_\" + app.name;\n  var invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n  document.body.appendChild(invisibleDiv);\n  var grecaptcha = getRecaptcha();\n\n  if (!grecaptcha) {\n    loadReCAPTCHAScript(function () {\n      var grecaptcha = getRecaptcha();\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n\n      grecaptcha.ready(function () {\n        // Invisible widgets allow us to set a different siteKey for each widget, so we use them to support multiple apps\n        renderInvisibleWidget(app, siteKey, grecaptcha, divId);\n        initialized.resolve(grecaptcha);\n      });\n    });\n  } else {\n    grecaptcha.ready(function () {\n      renderInvisibleWidget(app, siteKey, grecaptcha, divId);\n      initialized.resolve(grecaptcha);\n    });\n  }\n\n  return initialized.promise;\n}\n\nfunction getToken(app) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var reCAPTCHAState, recaptcha;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          ensureActivated(app);\n          reCAPTCHAState = getState(app).reCAPTCHAState;\n          return [4\n          /*yield*/\n          , reCAPTCHAState.initialized.promise];\n\n        case 1:\n          recaptcha = _a.sent();\n          return [2\n          /*return*/\n          , new Promise(function (resolve, _reject) {\n            // Updated after initialization is complete.\n            var reCAPTCHAState = getState(app).reCAPTCHAState;\n            recaptcha.ready(function () {\n              resolve( // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n              recaptcha.execute(reCAPTCHAState.widgetId, {\n                action: 'fire_app_check'\n              }));\n            });\n          })];\n      }\n    });\n  });\n}\n/**\r\n *\r\n * @param app\r\n * @param container - Id of a HTML element.\r\n */\n\n\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\n  var widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible'\n  });\n  var state = getState(app);\n  setState(app, tslib.__assign(tslib.__assign({}, state), {\n    reCAPTCHAState: tslib.__assign(tslib.__assign({}, state.reCAPTCHAState), {\n      // state.reCAPTCHAState is set in the initialize()\n      widgetId: widgetId\n    })\n  }));\n}\n\nfunction loadReCAPTCHAScript(onload) {\n  var script = document.createElement('script');\n  script.src = \"\" + RECAPTCHA_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n *\r\n * @param app\r\n * @param siteKeyOrProvider - optional custom attestation provider\r\n * or reCAPTCHA siteKey\r\n * @param isTokenAutoRefreshEnabled - if true, enables auto refresh\r\n * of appCheck token.\r\n */\n\n\nfunction activate(app, siteKeyOrProvider, isTokenAutoRefreshEnabled) {\n  var state = getState(app);\n\n  if (state.activated) {\n    throw ERROR_FACTORY.create(\"already-activated\"\n    /* ALREADY_ACTIVATED */\n    , {\n      appName: app.name\n    });\n  }\n\n  var newState = tslib.__assign(tslib.__assign({}, state), {\n    activated: true\n  });\n\n  if (typeof siteKeyOrProvider === 'string') {\n    newState.siteKey = siteKeyOrProvider;\n  } else {\n    newState.customProvider = siteKeyOrProvider;\n  } // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n\n\n  newState.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === undefined ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;\n  setState(app, newState); // initialize reCAPTCHA if siteKey is provided\n\n  if (newState.siteKey) {\n    initialize(app, newState.siteKey).catch(function () {\n      /* we don't care about the initialization result in activate() */\n    });\n  }\n}\n\nfunction setTokenAutoRefreshEnabled(app, isTokenAutoRefreshEnabled) {\n  var state = getState(app); // This will exist if any product libraries have called\n  // `addTokenListener()`\n\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n\n  setState(app, tslib.__assign(tslib.__assign({}, state), {\n    isTokenAutoRefreshEnabled: isTokenAutoRefreshEnabled\n  }));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1beta';\nvar EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaToken';\nvar EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\nvar TOKEN_REFRESH_TIME = {\n  /**\r\n   * The offset time before token natural expiration to run the refresh.\r\n   * This is currently 5 minutes.\r\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n\n  /**\r\n   * This is the first retrial wait after an error. This is currently\r\n   * 30 seconds.\r\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n\n  /**\r\n   * This is the maximum retrial wait, currently 16 minutes.\r\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Port from auth proactiverefresh.js\r\n *\r\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\n\nvar Refresher =\n/** @class */\nfunction () {\n  function Refresher(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\n    this.operation = operation;\n    this.retryPolicy = retryPolicy;\n    this.getWaitDuration = getWaitDuration;\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n    this.pending = null;\n    this.nextErrorWaitInterval = lowerBound;\n\n    if (lowerBound > upperBound) {\n      throw new Error('Proactive refresh lower bound greater than upper bound!');\n    }\n  }\n\n  Refresher.prototype.start = function () {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(function () {\n      /* we don't care about the result */\n    });\n  };\n\n  Refresher.prototype.stop = function () {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  };\n\n  Refresher.prototype.isRunning = function () {\n    return !!this.pending;\n  };\n\n  Refresher.prototype.process = function (hasSucceeded) {\n    return tslib.__awaiter(this, void 0, void 0, function () {\n      var error_1;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.stop();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 6,, 7]);\n\n            this.pending = new util.Deferred();\n            return [4\n            /*yield*/\n            , sleep(this.getNextRun(hasSucceeded))];\n\n          case 2:\n            _a.sent(); // Why do we resolve a promise, then immediate wait for it?\n            // We do it to make the promise chain cancellable.\n            // We can call stop() which rejects the promise before the following line execute, which makes\n            // the code jump to the catch block.\n            // TODO: unit test this\n\n\n            this.pending.resolve();\n            return [4\n            /*yield*/\n            , this.pending.promise];\n\n          case 3:\n            _a.sent();\n\n            this.pending = new util.Deferred();\n            return [4\n            /*yield*/\n            , this.operation()];\n\n          case 4:\n            _a.sent();\n\n            this.pending.resolve();\n            return [4\n            /*yield*/\n            , this.pending.promise];\n\n          case 5:\n            _a.sent();\n\n            this.process(true).catch(function () {\n              /* we don't care about the result */\n            });\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            error_1 = _a.sent();\n\n            if (this.retryPolicy(error_1)) {\n              this.process(false).catch(function () {\n                /* we don't care about the result */\n              });\n            } else {\n              this.stop();\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Refresher.prototype.getNextRun = function (hasSucceeded) {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound; // Return typical wait duration interval after a successful operation.\n\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      var currentErrorWaitInterval = this.nextErrorWaitInterval; // Double interval for next consecutive error.\n\n      this.nextErrorWaitInterval *= 2; // Make sure next wait interval does not exceed the maximum upper bound.\n\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n\n      return currentErrorWaitInterval;\n    }\n  };\n\n  return Refresher;\n}();\n\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, ms);\n  });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction exchangeToken(_a, platformLoggerProvider) {\n  var url = _a.url,\n      body = _a.body;\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var headers, platformLogger, options, response, originalError_1, responseBody, originalError_2, match, timeToLiveAsNumber, now;\n    return tslib.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          headers = {\n            'Content-Type': 'application/json'\n          };\n          platformLogger = platformLoggerProvider.getImmediate({\n            optional: true\n          });\n\n          if (platformLogger) {\n            headers['X-Firebase-Client'] = platformLogger.getPlatformInfoString();\n          }\n\n          options = {\n            method: 'POST',\n            body: JSON.stringify(body),\n            headers: headers\n          };\n          _b.label = 1;\n\n        case 1:\n          _b.trys.push([1, 3,, 4]);\n\n          return [4\n          /*yield*/\n          , fetch(url, options)];\n\n        case 2:\n          response = _b.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          originalError_1 = _b.sent();\n          throw ERROR_FACTORY.create(\"fetch-network-error\"\n          /* FETCH_NETWORK_ERROR */\n          , {\n            originalErrorMessage: originalError_1.message\n          });\n\n        case 4:\n          if (response.status !== 200) {\n            throw ERROR_FACTORY.create(\"fetch-status-error\"\n            /* FETCH_STATUS_ERROR */\n            , {\n              httpStatus: response.status\n            });\n          }\n\n          _b.label = 5;\n\n        case 5:\n          _b.trys.push([5, 7,, 8]);\n\n          return [4\n          /*yield*/\n          , response.json()];\n\n        case 6:\n          // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n          responseBody = _b.sent();\n          return [3\n          /*break*/\n          , 8];\n\n        case 7:\n          originalError_2 = _b.sent();\n          throw ERROR_FACTORY.create(\"fetch-parse-error\"\n          /* FETCH_PARSE_ERROR */\n          , {\n            originalErrorMessage: originalError_2.message\n          });\n\n        case 8:\n          match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n\n          if (!match || !match[2] || isNaN(Number(match[1]))) {\n            throw ERROR_FACTORY.create(\"fetch-parse-error\"\n            /* FETCH_PARSE_ERROR */\n            , {\n              originalErrorMessage: \"ttl field (timeToLive) is not in standard Protobuf Duration \" + (\"format: \" + responseBody.ttl)\n            });\n          }\n\n          timeToLiveAsNumber = Number(match[1]) * 1000;\n          now = Date.now();\n          return [2\n          /*return*/\n          , {\n            token: responseBody.attestationToken,\n            expireTimeMillis: now + timeToLiveAsNumber,\n            issuedAtTimeMillis: now\n          }];\n      }\n    });\n  });\n}\n\nfunction getExchangeRecaptchaTokenRequest(app, reCAPTCHAToken) {\n  var _a = app.options,\n      projectId = _a.projectId,\n      appId = _a.appId,\n      apiKey = _a.apiKey;\n  return {\n    url: BASE_ENDPOINT + \"/projects/\" + projectId + \"/apps/\" + appId + \":\" + EXCHANGE_RECAPTCHA_TOKEN_METHOD + \"?key=\" + apiKey,\n    body: {\n      // eslint-disable-next-line\n      recaptcha_token: reCAPTCHAToken\n    }\n  };\n}\n\nfunction getExchangeDebugTokenRequest(app, debugToken) {\n  var _a = app.options,\n      projectId = _a.projectId,\n      appId = _a.appId,\n      apiKey = _a.apiKey;\n  return {\n    url: BASE_ENDPOINT + \"/projects/\" + projectId + \"/apps/\" + appId + \":\" + EXCHANGE_DEBUG_TOKEN_METHOD + \"?key=\" + apiKey,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DB_NAME = 'firebase-app-check-database';\nvar DB_VERSION = 1;\nvar STORE_NAME = 'firebase-app-check-store';\nvar DEBUG_TOKEN_KEY = 'debug-token';\nvar dbPromise = null;\n\nfunction getDBPromise() {\n  if (dbPromise) {\n    return dbPromise;\n  }\n\n  dbPromise = new Promise(function (resolve, reject) {\n    try {\n      var request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onsuccess = function (event) {\n        resolve(event.target.result);\n      };\n\n      request.onerror = function (event) {\n        var _a;\n\n        reject(ERROR_FACTORY.create(\"storage-open\"\n        /* STORAGE_OPEN */\n        , {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n\n      request.onupgradeneeded = function (event) {\n        var db = event.target.result; // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(ERROR_FACTORY.create(\"storage-open\"\n      /* STORAGE_OPEN */\n      , {\n        originalErrorMessage: e.message\n      }));\n    }\n  });\n  return dbPromise;\n}\n\nfunction readTokenFromIndexedDB(app) {\n  return read(computeKey(app));\n}\n\nfunction writeTokenToIndexedDB(app, token) {\n  return write(computeKey(app), token);\n}\n\nfunction writeDebugTokenToIndexedDB(token) {\n  return write(DEBUG_TOKEN_KEY, token);\n}\n\nfunction readDebugTokenFromIndexedDB() {\n  return read(DEBUG_TOKEN_KEY);\n}\n\nfunction write(key, value) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var db, transaction, store, request;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , getDBPromise()];\n\n        case 1:\n          db = _a.sent();\n          transaction = db.transaction(STORE_NAME, 'readwrite');\n          store = transaction.objectStore(STORE_NAME);\n          request = store.put({\n            compositeKey: key,\n            value: value\n          });\n          return [2\n          /*return*/\n          , new Promise(function (resolve, reject) {\n            request.onsuccess = function (_event) {\n              resolve();\n            };\n\n            transaction.onerror = function (event) {\n              var _a;\n\n              reject(ERROR_FACTORY.create(\"storage-set\"\n              /* STORAGE_WRITE */\n              , {\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n              }));\n            };\n          })];\n      }\n    });\n  });\n}\n\nfunction read(key) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var db, transaction, store, request;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , getDBPromise()];\n\n        case 1:\n          db = _a.sent();\n          transaction = db.transaction(STORE_NAME, 'readonly');\n          store = transaction.objectStore(STORE_NAME);\n          request = store.get(key);\n          return [2\n          /*return*/\n          , new Promise(function (resolve, reject) {\n            request.onsuccess = function (event) {\n              var result = event.target.result;\n\n              if (result) {\n                resolve(result.value);\n              } else {\n                resolve(undefined);\n              }\n            };\n\n            transaction.onerror = function (event) {\n              var _a;\n\n              reject(ERROR_FACTORY.create(\"storage-get\"\n              /* STORAGE_GET */\n              , {\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n              }));\n            };\n          })];\n      }\n    });\n  });\n}\n\nfunction computeKey(app) {\n  return app.options.appId + \"-\" + app.name;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar logger = new logger$1.Logger('@firebase/app-check');\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\r\n */\n\nfunction readTokenFromStorage(app) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var token, e_1;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!util.isIndexedDBAvailable()) return [3\n          /*break*/\n          , 5];\n          token = undefined;\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1, 3,, 4]);\n\n          return [4\n          /*yield*/\n          , readTokenFromIndexedDB(app)];\n\n        case 2:\n          token = _a.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          e_1 = _a.sent(); // swallow the error and return undefined\n\n          logger.warn(\"Failed to read token from indexeddb. Error: \" + e_1);\n          return [3\n          /*break*/\n          , 4];\n\n        case 4:\n          return [2\n          /*return*/\n          , token];\n\n        case 5:\n          return [2\n          /*return*/\n          , undefined];\n      }\n    });\n  });\n}\n/**\r\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\r\n */\n\n\nfunction writeTokenToStorage(app, token) {\n  if (util.isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(function (e) {\n      // swallow the error and resolve the promise\n      logger.warn(\"Failed to write token to indexeddb. Error: \" + e);\n    });\n  }\n\n  return Promise.resolve();\n}\n\nfunction readOrCreateDebugTokenFromStorage() {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var existingDebugToken, _e_1, newToken;\n\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          existingDebugToken = undefined;\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1, 3,, 4]);\n\n          return [4\n          /*yield*/\n          , readDebugTokenFromIndexedDB()];\n\n        case 2:\n          existingDebugToken = _a.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          _e_1 = _a.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 4:\n          if (!existingDebugToken) {\n            newToken = uuidv4(); // We don't need to block on writing to indexeddb\n            // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\n            // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n            // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n            // You should switch to a different browser that supports indexeddb\n\n            writeDebugTokenToIndexedDB(newToken).catch(function (e) {\n              return logger.warn(\"Failed to persist debug token to indexeddb. Error: \" + e);\n            }); // Not using logger because I don't think we ever want this accidentally hidden?\n\n            console.log(\"AppCheck debug token: \" + newToken + \". You will need to whitelist it in the Firebase console for it to work\");\n            return [2\n            /*return*/\n            , newToken];\n          } else {\n            return [2\n            /*return*/\n            , existingDebugToken];\n          }\n\n      }\n    });\n  });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction isDebugMode() {\n  var debugState = getDebugState();\n  return debugState.enabled;\n}\n\nfunction getDebugToken() {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var state;\n    return tslib.__generator(this, function (_a) {\n      state = getDebugState();\n\n      if (state.enabled && state.token) {\n        return [2\n        /*return*/\n        , state.token.promise];\n      } else {\n        // should not happen!\n        throw Error(\"\\n            Can't get debug token in production mode.\\n        \");\n      }\n    });\n  });\n}\n\nfunction initializeDebugMode() {\n  var globals = util.getGlobal();\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\n    return;\n  }\n\n  var debugState = getDebugState();\n  debugState.enabled = true;\n  var deferredToken = new util.Deferred();\n  debugState.token = deferredToken;\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\n\n\nvar defaultTokenErrorData = {\n  error: 'UNKNOWN_ERROR'\n};\n/**\r\n * Stringify and base64 encode token error data.\r\n *\r\n * @param tokenError Error data, currently hardcoded.\r\n */\n\nfunction formatDummyToken(tokenErrorData) {\n  return util.base64.encodeString(JSON.stringify(tokenErrorData),\n  /* webSafe= */\n  false);\n}\n/**\r\n * This function will always resolve.\r\n * The result will contain an error field if there is any error.\r\n * In case there is an error, the token field in the result will be populated with a dummy value\r\n */\n\n\nfunction getToken$1(app, platformLoggerProvider, forceRefresh) {\n  if (forceRefresh === void 0) {\n    forceRefresh = false;\n  }\n\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var tokenFromDebugExchange, _a, _b, _c, state, token, error, cachedToken, customToken, issuedAtTimeSeconds, issuedAtTimeMillis, attestedClaimsToken, e_1, interopTokenResult;\n\n    return tslib.__generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          ensureActivated(app);\n          if (!isDebugMode()) return [3\n          /*break*/\n          , 3];\n          _a = exchangeToken;\n          _b = getExchangeDebugTokenRequest;\n          _c = [app];\n          return [4\n          /*yield*/\n          , getDebugToken()];\n\n        case 1:\n          return [4\n          /*yield*/\n          , _a.apply(void 0, [_b.apply(void 0, _c.concat([_d.sent()])), platformLoggerProvider])];\n\n        case 2:\n          tokenFromDebugExchange = _d.sent();\n          return [2\n          /*return*/\n          , {\n            token: tokenFromDebugExchange.token\n          }];\n\n        case 3:\n          state = getState(app);\n          token = state.token;\n          error = undefined;\n          if (!!token) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , readTokenFromStorage(app)];\n\n        case 4:\n          cachedToken = _d.sent();\n\n          if (cachedToken && isValid(cachedToken)) {\n            token = cachedToken;\n            setState(app, tslib.__assign(tslib.__assign({}, state), {\n              token: token\n            })); // notify all listeners with the cached token\n\n            notifyTokenListeners(app, {\n              token: token.token\n            });\n          }\n\n          _d.label = 5;\n\n        case 5:\n          // return the cached token if it's valid\n          if (!forceRefresh && token && isValid(token)) {\n            return [2\n            /*return*/\n            , {\n              token: token.token\n            }];\n          }\n\n          _d.label = 6;\n\n        case 6:\n          _d.trys.push([6, 12,, 13]);\n\n          if (!state.customProvider) return [3\n          /*break*/\n          , 8];\n          return [4\n          /*yield*/\n          , state.customProvider.getToken()];\n\n        case 7:\n          customToken = _d.sent();\n          issuedAtTimeSeconds = util.issuedAtTime(customToken.token);\n          issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1000 : Date.now();\n          token = tslib.__assign(tslib.__assign({}, customToken), {\n            issuedAtTimeMillis: issuedAtTimeMillis\n          });\n          return [3\n          /*break*/\n          , 11];\n\n        case 8:\n          return [4\n          /*yield*/\n          , getToken(app).catch(function (_e) {\n            // reCaptcha.execute() throws null which is not very descriptive.\n            throw ERROR_FACTORY.create(\"recaptcha-error\"\n            /* RECAPTCHA_ERROR */\n            );\n          })];\n\n        case 9:\n          attestedClaimsToken = _d.sent();\n          return [4\n          /*yield*/\n          , exchangeToken(getExchangeRecaptchaTokenRequest(app, attestedClaimsToken), platformLoggerProvider)];\n\n        case 10:\n          token = _d.sent();\n          _d.label = 11;\n\n        case 11:\n          return [3\n          /*break*/\n          , 13];\n\n        case 12:\n          e_1 = _d.sent(); // `getToken()` should never throw, but logging error text to console will aid debugging.\n\n          logger.error(e_1);\n          error = e_1;\n          return [3\n          /*break*/\n          , 13];\n\n        case 13:\n          if (!!token) return [3\n          /*break*/\n          , 14]; // if token is undefined, there must be an error.\n          // we return a dummy token along with the error\n\n          interopTokenResult = makeDummyTokenResult(error);\n          return [3\n          /*break*/\n          , 16];\n\n        case 14:\n          interopTokenResult = {\n            token: token.token\n          }; // write the new token to the memory state as well ashe persistent storage.\n          // Only do it if we got a valid new token\n\n          setState(app, tslib.__assign(tslib.__assign({}, state), {\n            token: token\n          }));\n          return [4\n          /*yield*/\n          , writeTokenToStorage(app, token)];\n\n        case 15:\n          _d.sent();\n\n          _d.label = 16;\n\n        case 16:\n          notifyTokenListeners(app, interopTokenResult);\n          return [2\n          /*return*/\n          , interopTokenResult];\n      }\n    });\n  });\n}\n\nfunction addTokenListener(app, platformLoggerProvider, listener) {\n  var state = getState(app);\n\n  var newState = tslib.__assign(tslib.__assign({}, state), {\n    tokenListeners: tslib.__spreadArray(tslib.__spreadArray([], state.tokenListeners), [listener])\n  });\n  /**\r\n   * DEBUG MODE\r\n   *\r\n   * invoke the listener once with the debug token.\r\n   */\n\n\n  if (isDebugMode()) {\n    var debugState = getDebugState();\n\n    if (debugState.enabled && debugState.token) {\n      debugState.token.promise.then(function (token) {\n        return listener({\n          token: token\n        });\n      }).catch(function () {\n        /* we don't care about exceptions thrown in listeners */\n      });\n    }\n  } else {\n    /**\r\n     * PROD MODE\r\n     *\r\n     * invoke the listener with the valid token, then start the token refresher\r\n     */\n    if (!newState.tokenRefresher) {\n      var tokenRefresher = createTokenRefresher(app, platformLoggerProvider);\n      newState.tokenRefresher = tokenRefresher;\n    } // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n    // is not true.\n\n\n    if (!newState.tokenRefresher.isRunning() && state.isTokenAutoRefreshEnabled === true) {\n      newState.tokenRefresher.start();\n    } // invoke the listener async immediately if there is a valid token\n\n\n    if (state.token && isValid(state.token)) {\n      var validToken_1 = state.token;\n      Promise.resolve().then(function () {\n        return listener({\n          token: validToken_1.token\n        });\n      }).catch(function () {\n        /* we don't care about exceptions thrown in listeners */\n      });\n    }\n  }\n\n  setState(app, newState);\n}\n\nfunction removeTokenListener(app, listener) {\n  var state = getState(app);\n  var newListeners = state.tokenListeners.filter(function (l) {\n    return l !== listener;\n  });\n\n  if (newListeners.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {\n    state.tokenRefresher.stop();\n  }\n\n  setState(app, tslib.__assign(tslib.__assign({}, state), {\n    tokenListeners: newListeners\n  }));\n}\n\nfunction createTokenRefresher(app, platformLoggerProvider) {\n  var _this = this;\n\n  return new Refresher( // Keep in mind when this fails for any reason other than the ones\n  // for which we should retry, it will effectively stop the proactive refresh.\n  function () {\n    return tslib.__awaiter(_this, void 0, void 0, function () {\n      var state, result;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            state = getState(app);\n            if (!!state.token) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , getToken$1(app, platformLoggerProvider)];\n\n          case 1:\n            result = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , getToken$1(app, platformLoggerProvider, true)];\n\n          case 3:\n            result = _a.sent();\n            _a.label = 4;\n\n          case 4:\n            // getToken() always resolves. In case the result has an error field defined, it means the operation failed, and we should retry.\n            if (result.error) {\n              throw result.error;\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, function () {\n    // TODO: when should we retry?\n    return true;\n  }, function () {\n    var state = getState(app);\n\n    if (state.token) {\n      // issuedAtTime + (50% * total TTL) + 5 minutes\n      var nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1000; // Do not allow refresh time to be past (expireTime - 5 minutes)\n\n      var latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\n      nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\n      return Math.max(0, nextRefreshTimeMillis - Date.now());\n    } else {\n      return 0;\n    }\n  }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\n}\n\nfunction notifyTokenListeners(app, token) {\n  var listeners = getState(app).tokenListeners;\n\n  for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {\n    var listener = listeners_1[_i];\n\n    try {\n      listener(token);\n    } catch (e) {// If any handler fails, ignore and run next handler.\n    }\n  }\n}\n\nfunction isValid(token) {\n  return token.expireTimeMillis - Date.now() > 0;\n}\n\nfunction makeDummyTokenResult(error) {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error: error\n  };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction factory(app) {\n  return {\n    activate: function (siteKeyOrProvider, isTokenAutoRefreshEnabled) {\n      return activate(app, siteKeyOrProvider, isTokenAutoRefreshEnabled);\n    },\n    setTokenAutoRefreshEnabled: function (isTokenAutoRefreshEnabled) {\n      return setTokenAutoRefreshEnabled(app, isTokenAutoRefreshEnabled);\n    }\n  };\n}\n\nfunction internalFactory(app, platformLoggerProvider) {\n  return {\n    getToken: function (forceRefresh) {\n      return getToken$1(app, platformLoggerProvider, forceRefresh);\n    },\n    addTokenListener: function (listener) {\n      return addTokenListener(app, platformLoggerProvider, listener);\n    },\n    removeTokenListener: function (listener) {\n      return removeTokenListener(app, listener);\n    }\n  };\n}\n\nvar name = \"@firebase/app-check\";\nvar version = \"0.1.2\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar APP_CHECK_NAME = 'appCheck';\nvar APP_CHECK_NAME_INTERNAL = 'app-check-internal';\n\nfunction registerAppCheck(firebase) {\n  // The public interface\n  firebase.INTERNAL.registerComponent(new component.Component(APP_CHECK_NAME, function (container) {\n    // getImmediate for FirebaseApp will always succeed\n    var app = container.getProvider('app').getImmediate();\n    return factory(app);\n  }, \"PUBLIC\"\n  /* PUBLIC */\n  )\n  /**\r\n   * AppCheck can only be initialized by explicitly calling firebase.appCheck()\r\n   * We don't want firebase products that consume AppCheck to gate on AppCheck\r\n   * if the user doesn't intend them to, just because the AppCheck component\r\n   * is registered.\r\n   */\n  .setInstantiationMode(\"EXPLICIT\"\n  /* EXPLICIT */\n  )\n  /**\r\n   * Because all firebase products that depend on app-check depend on app-check-internal directly,\r\n   * we need to initialize app-check-internal after app-check is initialized to make it\r\n   * available to other firebase products.\r\n   */\n  .setInstanceCreatedCallback(function (container, _instanceIdentifier, _instance) {\n    var appCheckInternalProvider = container.getProvider(APP_CHECK_NAME_INTERNAL);\n    appCheckInternalProvider.initialize();\n  })); // The internal interface used by other Firebase products\n\n  firebase.INTERNAL.registerComponent(new component.Component(APP_CHECK_NAME_INTERNAL, function (container) {\n    // getImmediate for FirebaseApp will always succeed\n    var app = container.getProvider('app').getImmediate();\n    var platformLoggerProvider = container.getProvider('platform-logger');\n    return internalFactory(app, platformLoggerProvider);\n  }, \"PUBLIC\"\n  /* PUBLIC */\n  ).setInstantiationMode(\"EXPLICIT\"\n  /* EXPLICIT */\n  ));\n  firebase.registerVersion(name, version);\n}\n\nregisterAppCheck(firebase__default['default']);\ninitializeDebugMode();","map":{"version":3,"sources":["../src/errors.ts","../src/state.ts","../src/util.ts","../src/recaptcha.ts","../src/api.ts","../src/constants.ts","../src/proactive-refresh.ts","../src/client.ts","../src/indexeddb.ts","../src/logger.ts","../src/storage.ts","../src/debug.ts","../src/internal-api.ts","../src/factory.ts","../src/index.ts"],"names":["ErrorFactory","Deferred","initializeRecaptcha","Logger","isIndexedDBAvailable","getGlobal","base64","getToken","issuedAtTime","getReCAPTCHAToken","Component","firebase"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum AppCheckError {\n  ALREADY_ACTIVATED = 'already-activated',\n  USE_BEFORE_ACTIVATION = 'use-before-activation',\n  FETCH_NETWORK_ERROR = 'fetch-network-error',\n  FETCH_PARSE_ERROR = 'fetch-parse-error',\n  FETCH_STATUS_ERROR = 'fetch-status-error',\n  STORAGE_OPEN = 'storage-open',\n  STORAGE_GET = 'storage-get',\n  STORAGE_WRITE = 'storage-set',\n  RECAPTCHA_ERROR = 'recaptcha-error'\n}\n\nconst ERRORS: ErrorMap<AppCheckError> = {\n  [AppCheckError.ALREADY_ACTIVATED]:\n    'You are trying to activate AppCheck for FirebaseApp {$appName}, ' +\n    'while it is already activated. ' +\n    'AppCheck can only be activated once.',\n  [AppCheckError.USE_BEFORE_ACTIVATION]:\n    'AppCheck is being used before activate() is called for FirebaseApp {$appName}. ' +\n    'Please make sure you call activate() before instantiating other Firebase services.',\n  [AppCheckError.FETCH_NETWORK_ERROR]:\n    'Fetch failed to connect to a network. Check Internet connection. ' +\n    'Original error: {$originalErrorMessage}.',\n  [AppCheckError.FETCH_PARSE_ERROR]:\n    'Fetch client could not parse response.' +\n    ' Original error: {$originalErrorMessage}.',\n  [AppCheckError.FETCH_STATUS_ERROR]:\n    'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n  [AppCheckError.STORAGE_OPEN]:\n    'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.STORAGE_GET]:\n    'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.STORAGE_WRITE]:\n    'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.RECAPTCHA_ERROR]: 'ReCAPTCHA error.'\n};\n\ninterface ErrorParams {\n  [AppCheckError.ALREADY_ACTIVATED]: { appName: string };\n  [AppCheckError.USE_BEFORE_ACTIVATION]: { appName: string };\n  [AppCheckError.FETCH_NETWORK_ERROR]: { originalErrorMessage: string };\n  [AppCheckError.FETCH_PARSE_ERROR]: { originalErrorMessage: string };\n  [AppCheckError.FETCH_STATUS_ERROR]: { httpStatus: number };\n  [AppCheckError.STORAGE_OPEN]: { originalErrorMessage?: string };\n  [AppCheckError.STORAGE_GET]: { originalErrorMessage?: string };\n  [AppCheckError.STORAGE_WRITE]: { originalErrorMessage?: string };\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<AppCheckError, ErrorParams>(\n  'appCheck',\n  'AppCheck',\n  ERRORS\n);\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { AppCheckProvider, AppCheckToken } from '@firebase/app-check-types';\nimport { AppCheckTokenListener } from '@firebase/app-check-interop-types';\nimport { Refresher } from './proactive-refresh';\nimport { Deferred } from '@firebase/util';\nimport { GreCAPTCHA } from './recaptcha';\n\nexport interface AppCheckTokenInternal extends AppCheckToken {\n  issuedAtTimeMillis: number;\n}\nexport interface AppCheckState {\n  activated: boolean;\n  tokenListeners: AppCheckTokenListener[];\n  customProvider?: AppCheckProvider;\n  siteKey?: string;\n  token?: AppCheckTokenInternal;\n  tokenRefresher?: Refresher;\n  reCAPTCHAState?: ReCAPTCHAState;\n  isTokenAutoRefreshEnabled?: boolean;\n}\n\nexport interface ReCAPTCHAState {\n  initialized: Deferred<GreCAPTCHA>;\n  widgetId?: string;\n}\n\nexport interface DebugState {\n  enabled: boolean;\n  token?: Deferred<string>;\n}\n\nconst APP_CHECK_STATES = new Map<FirebaseApp, AppCheckState>();\nexport const DEFAULT_STATE: AppCheckState = {\n  activated: false,\n  tokenListeners: []\n};\n\nconst DEBUG_STATE: DebugState = {\n  enabled: false\n};\n\nexport function getState(app: FirebaseApp): AppCheckState {\n  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;\n}\n\nexport function setState(app: FirebaseApp, state: AppCheckState): void {\n  APP_CHECK_STATES.set(app, state);\n}\n\n// for testing only\nexport function clearState(): void {\n  APP_CHECK_STATES.clear();\n  DEBUG_STATE.enabled = false;\n  DEBUG_STATE.token = undefined;\n}\n\nexport function getDebugState(): DebugState {\n  return DEBUG_STATE;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GreCAPTCHA } from './recaptcha';\nimport { getState } from './state';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { FirebaseApp } from '@firebase/app-types';\n\nexport function getRecaptcha(): GreCAPTCHA | undefined {\n  return self.grecaptcha;\n}\n\nexport function ensureActivated(app: FirebaseApp): void {\n  if (!getState(app).activated) {\n    throw ERROR_FACTORY.create(AppCheckError.USE_BEFORE_ACTIVATION, {\n      appName: app.name\n    });\n  }\n}\n\n/**\n * Copied from https://stackoverflow.com/a/2117523\n */\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16) | 0,\n      v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { getState, setState } from './state';\nimport { Deferred } from '@firebase/util';\nimport { getRecaptcha, ensureActivated } from './util';\n\nexport const RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\n\nexport function initialize(\n  app: FirebaseApp,\n  siteKey: string\n): Promise<GreCAPTCHA> {\n  const state = getState(app);\n  const initialized = new Deferred<GreCAPTCHA>();\n\n  setState(app, { ...state, reCAPTCHAState: { initialized } });\n\n  const divId = `fire_app_check_${app.name}`;\n  const invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n\n  document.body.appendChild(invisibleDiv);\n\n  const grecaptcha = getRecaptcha();\n  if (!grecaptcha) {\n    loadReCAPTCHAScript(() => {\n      const grecaptcha = getRecaptcha();\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      grecaptcha.ready(() => {\n        // Invisible widgets allow us to set a different siteKey for each widget, so we use them to support multiple apps\n        renderInvisibleWidget(app, siteKey, grecaptcha, divId);\n        initialized.resolve(grecaptcha);\n      });\n    });\n  } else {\n    grecaptcha.ready(() => {\n      renderInvisibleWidget(app, siteKey, grecaptcha, divId);\n      initialized.resolve(grecaptcha);\n    });\n  }\n\n  return initialized.promise;\n}\n\nexport async function getToken(app: FirebaseApp): Promise<string> {\n  ensureActivated(app);\n\n  // ensureActivated() guarantees that reCAPTCHAState is set\n  const reCAPTCHAState = getState(app).reCAPTCHAState!;\n  const recaptcha = await reCAPTCHAState.initialized.promise;\n\n  return new Promise((resolve, _reject) => {\n    // Updated after initialization is complete.\n    const reCAPTCHAState = getState(app).reCAPTCHAState!;\n    recaptcha.ready(() => {\n      resolve(\n        // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n        recaptcha.execute(reCAPTCHAState.widgetId!, {\n          action: 'fire_app_check'\n        })\n      );\n    });\n  });\n}\n\n/**\n *\n * @param app\n * @param container - Id of a HTML element.\n */\nfunction renderInvisibleWidget(\n  app: FirebaseApp,\n  siteKey: string,\n  grecaptcha: GreCAPTCHA,\n  container: string\n): void {\n  const widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible'\n  });\n\n  const state = getState(app);\n\n  setState(app, {\n    ...state,\n    reCAPTCHAState: {\n      ...state.reCAPTCHAState!, // state.reCAPTCHAState is set in the initialize()\n      widgetId\n    }\n  });\n}\n\nfunction loadReCAPTCHAScript(onload: () => void): void {\n  const script = document.createElement('script');\n  script.src = `${RECAPTCHA_URL}`;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\ndeclare global {\n  interface Window {\n    grecaptcha: GreCAPTCHA | undefined;\n  }\n}\n\nexport interface GreCAPTCHA {\n  ready: (callback: () => void) => void;\n  execute: (siteKey: string, options: { action: string }) => Promise<string>;\n  render: (\n    container: string | HTMLElement,\n    parameters: GreCAPTCHARenderOption\n  ) => string;\n}\n\nexport interface GreCAPTCHARenderOption {\n  sitekey: string;\n  size: 'invisible';\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppCheckProvider } from '@firebase/app-check-types';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { initialize as initializeRecaptcha } from './recaptcha';\nimport { getState, setState, AppCheckState } from './state';\n\n/**\n *\n * @param app\n * @param siteKeyOrProvider - optional custom attestation provider\n * or reCAPTCHA siteKey\n * @param isTokenAutoRefreshEnabled - if true, enables auto refresh\n * of appCheck token.\n */\nexport function activate(\n  app: FirebaseApp,\n  siteKeyOrProvider: string | AppCheckProvider,\n  isTokenAutoRefreshEnabled?: boolean\n): void {\n  const state = getState(app);\n  if (state.activated) {\n    throw ERROR_FACTORY.create(AppCheckError.ALREADY_ACTIVATED, {\n      appName: app.name\n    });\n  }\n\n  const newState: AppCheckState = { ...state, activated: true };\n  if (typeof siteKeyOrProvider === 'string') {\n    newState.siteKey = siteKeyOrProvider;\n  } else {\n    newState.customProvider = siteKeyOrProvider;\n  }\n\n  // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n  newState.isTokenAutoRefreshEnabled =\n    isTokenAutoRefreshEnabled === undefined\n      ? app.automaticDataCollectionEnabled\n      : isTokenAutoRefreshEnabled;\n\n  setState(app, newState);\n\n  // initialize reCAPTCHA if siteKey is provided\n  if (newState.siteKey) {\n    initializeRecaptcha(app, newState.siteKey).catch(() => {\n      /* we don't care about the initialization result in activate() */\n    });\n  }\n}\n\nexport function setTokenAutoRefreshEnabled(\n  app: FirebaseApp,\n  isTokenAutoRefreshEnabled: boolean\n): void {\n  const state = getState(app);\n  // This will exist if any product libraries have called\n  // `addTokenListener()`\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n  setState(app, { ...state, isTokenAutoRefreshEnabled });\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const BASE_ENDPOINT =\n  'https://content-firebaseappcheck.googleapis.com/v1beta';\n\nexport const EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaToken';\nexport const EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\n\nexport const TOKEN_REFRESH_TIME = {\n  /**\n   * The offset time before token natural expiration to run the refresh.\n   * This is currently 5 minutes.\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n  /**\n   * This is the first retrial wait after an error. This is currently\n   * 30 seconds.\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n  /**\n   * This is the maximum retrial wait, currently 16 minutes.\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Deferred } from '@firebase/util';\n\n/**\n * Port from auth proactiverefresh.js\n *\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\nexport class Refresher {\n  private pending: Deferred<unknown> | null = null;\n  private nextErrorWaitInterval: number;\n  constructor(\n    private readonly operation: () => Promise<unknown>,\n    private readonly retryPolicy: (error: unknown) => boolean,\n    private readonly getWaitDuration: () => number,\n    private readonly lowerBound: number,\n    private readonly upperBound: number\n  ) {\n    this.nextErrorWaitInterval = lowerBound;\n\n    if (lowerBound > upperBound) {\n      throw new Error(\n        'Proactive refresh lower bound greater than upper bound!'\n      );\n    }\n  }\n\n  start(): void {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(() => {\n      /* we don't care about the result */\n    });\n  }\n\n  stop(): void {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  }\n\n  isRunning(): boolean {\n    return !!this.pending;\n  }\n\n  private async process(hasSucceeded: boolean): Promise<void> {\n    this.stop();\n    try {\n      this.pending = new Deferred();\n      await sleep(this.getNextRun(hasSucceeded));\n\n      // Why do we resolve a promise, then immediate wait for it?\n      // We do it to make the promise chain cancellable.\n      // We can call stop() which rejects the promise before the following line execute, which makes\n      // the code jump to the catch block.\n      // TODO: unit test this\n      this.pending.resolve();\n      await this.pending.promise;\n      this.pending = new Deferred();\n      await this.operation();\n\n      this.pending.resolve();\n      await this.pending.promise;\n\n      this.process(true).catch(() => {\n        /* we don't care about the result */\n      });\n    } catch (error) {\n      if (this.retryPolicy(error)) {\n        this.process(false).catch(() => {\n          /* we don't care about the result */\n        });\n      } else {\n        this.stop();\n      }\n    }\n  }\n\n  private getNextRun(hasSucceeded: boolean): number {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound;\n      // Return typical wait duration interval after a successful operation.\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      const currentErrorWaitInterval = this.nextErrorWaitInterval;\n      // Double interval for next consecutive error.\n      this.nextErrorWaitInterval *= 2;\n      // Make sure next wait interval does not exceed the maximum upper bound.\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n      return currentErrorWaitInterval;\n    }\n  }\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BASE_ENDPOINT,\n  EXCHANGE_DEBUG_TOKEN_METHOD,\n  EXCHANGE_RECAPTCHA_TOKEN_METHOD\n} from './constants';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { Provider } from '@firebase/component';\nimport { AppCheckTokenInternal } from './state';\n\n/**\n * Response JSON returned from AppCheck server endpoint.\n */\ninterface AppCheckResponse {\n  attestationToken: string;\n  // timeToLive\n  ttl: string;\n}\n\ninterface AppCheckRequest {\n  url: string;\n  body: { [key: string]: string };\n}\n\nexport async function exchangeToken(\n  { url, body }: AppCheckRequest,\n  platformLoggerProvider: Provider<'platform-logger'>\n): Promise<AppCheckTokenInternal> {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json'\n  };\n  // If platform logger exists, add the platform info string to the header.\n  const platformLogger = platformLoggerProvider.getImmediate({\n    optional: true\n  });\n  if (platformLogger) {\n    headers['X-Firebase-Client'] = platformLogger.getPlatformInfoString();\n  }\n  const options: RequestInit = {\n    method: 'POST',\n    body: JSON.stringify(body),\n    headers\n  };\n  let response;\n  try {\n    response = await fetch(url, options);\n  } catch (originalError) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_NETWORK_ERROR, {\n      originalErrorMessage: originalError.message\n    });\n  }\n\n  if (response.status !== 200) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_STATUS_ERROR, {\n      httpStatus: response.status\n    });\n  }\n\n  let responseBody: AppCheckResponse;\n  try {\n    // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n    responseBody = await response.json();\n  } catch (originalError) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_PARSE_ERROR, {\n      originalErrorMessage: originalError.message\n    });\n  }\n\n  // Protobuf duration format.\n  // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n  const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n  if (!match || !match[2] || isNaN(Number(match[1]))) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_PARSE_ERROR, {\n      originalErrorMessage:\n        `ttl field (timeToLive) is not in standard Protobuf Duration ` +\n        `format: ${responseBody.ttl}`\n    });\n  }\n  const timeToLiveAsNumber = Number(match[1]) * 1000;\n\n  const now = Date.now();\n  return {\n    token: responseBody.attestationToken,\n    expireTimeMillis: now + timeToLiveAsNumber,\n    issuedAtTimeMillis: now\n  };\n}\n\nexport function getExchangeRecaptchaTokenRequest(\n  app: FirebaseApp,\n  reCAPTCHAToken: string\n): AppCheckRequest {\n  const { projectId, appId, apiKey } = app.options;\n\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      recaptcha_token: reCAPTCHAToken\n    }\n  };\n}\n\nexport function getExchangeDebugTokenRequest(\n  app: FirebaseApp,\n  debugToken: string\n): AppCheckRequest {\n  const { projectId, appId, apiKey } = app.options;\n\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { AppCheckTokenInternal } from './state';\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\n\nlet dbPromise: Promise<IDBDatabase> | null = null;\nfunction getDBPromise(): Promise<IDBDatabase> {\n  if (dbPromise) {\n    return dbPromise;\n  }\n\n  dbPromise = new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onsuccess = event => {\n        resolve((event.target as IDBOpenDBRequest).result);\n      };\n\n      request.onerror = event => {\n        reject(\n          ERROR_FACTORY.create(AppCheckError.STORAGE_OPEN, {\n            originalErrorMessage: (event.target as IDBRequest).error?.message\n          })\n        );\n      };\n\n      request.onupgradeneeded = event => {\n        const db = (event.target as IDBOpenDBRequest).result;\n\n        // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_OPEN, {\n          originalErrorMessage: e.message\n        })\n      );\n    }\n  });\n\n  return dbPromise;\n}\n\nexport function readTokenFromIndexedDB(\n  app: FirebaseApp\n): Promise<AppCheckTokenInternal | undefined> {\n  return read(computeKey(app)) as Promise<AppCheckTokenInternal | undefined>;\n}\n\nexport function writeTokenToIndexedDB(\n  app: FirebaseApp,\n  token: AppCheckTokenInternal\n): Promise<void> {\n  return write(computeKey(app), token);\n}\n\nexport function writeDebugTokenToIndexedDB(token: string): Promise<void> {\n  return write(DEBUG_TOKEN_KEY, token);\n}\n\nexport function readDebugTokenFromIndexedDB(): Promise<string | undefined> {\n  return read(DEBUG_TOKEN_KEY) as Promise<string | undefined>;\n}\n\nasync function write(key: string, value: unknown): Promise<void> {\n  const db = await getDBPromise();\n\n  const transaction = db.transaction(STORE_NAME, 'readwrite');\n  const store = transaction.objectStore(STORE_NAME);\n  const request = store.put({\n    compositeKey: key,\n    value\n  });\n\n  return new Promise((resolve, reject) => {\n    request.onsuccess = _event => {\n      resolve();\n    };\n\n    transaction.onerror = event => {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_WRITE, {\n          originalErrorMessage: (event.target as IDBRequest).error?.message\n        })\n      );\n    };\n  });\n}\n\nasync function read(key: string): Promise<unknown> {\n  const db = await getDBPromise();\n\n  const transaction = db.transaction(STORE_NAME, 'readonly');\n  const store = transaction.objectStore(STORE_NAME);\n  const request = store.get(key);\n\n  return new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      const result = (event.target as IDBRequest).result;\n\n      if (result) {\n        resolve(result.value);\n      } else {\n        resolve(undefined);\n      }\n    };\n\n    transaction.onerror = event => {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_GET, {\n          originalErrorMessage: (event.target as IDBRequest).error?.message\n        })\n      );\n    };\n  });\n}\n\nfunction computeKey(app: FirebaseApp): string {\n  return `${app.options.appId}-${app.name}`;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from '@firebase/logger';\n\nexport const logger = new Logger('@firebase/app-check');\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { uuidv4 } from './util';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { isIndexedDBAvailable } from '@firebase/util';\nimport {\n  readDebugTokenFromIndexedDB,\n  readTokenFromIndexedDB,\n  writeDebugTokenToIndexedDB,\n  writeTokenToIndexedDB\n} from './indexeddb';\nimport { logger } from './logger';\nimport { AppCheckTokenInternal } from './state';\n\n/**\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\n */\nexport async function readTokenFromStorage(\n  app: FirebaseApp\n): Promise<AppCheckTokenInternal | undefined> {\n  if (isIndexedDBAvailable()) {\n    let token = undefined;\n    try {\n      token = await readTokenFromIndexedDB(app);\n    } catch (e) {\n      // swallow the error and return undefined\n      logger.warn(`Failed to read token from indexeddb. Error: ${e}`);\n    }\n    return token;\n  }\n\n  return undefined;\n}\n\n/**\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\n */\nexport function writeTokenToStorage(\n  app: FirebaseApp,\n  token: AppCheckTokenInternal\n): Promise<void> {\n  if (isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(e => {\n      // swallow the error and resolve the promise\n      logger.warn(`Failed to write token to indexeddb. Error: ${e}`);\n    });\n  }\n\n  return Promise.resolve();\n}\n\nexport async function readOrCreateDebugTokenFromStorage(): Promise<string> {\n  /**\n   * Theoretically race condition can happen if we read, then write in 2 separate transactions.\n   * But it won't happen here, because this function will be called exactly once.\n   */\n  let existingDebugToken: string | undefined = undefined;\n  try {\n    existingDebugToken = await readDebugTokenFromIndexedDB();\n  } catch (_e) {\n    // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n  }\n\n  if (!existingDebugToken) {\n    // create a new debug token\n    const newToken = uuidv4();\n    // We don't need to block on writing to indexeddb\n    // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\n    // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n    // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n    // You should switch to a different browser that supports indexeddb\n    writeDebugTokenToIndexedDB(newToken).catch(e =>\n      logger.warn(`Failed to persist debug token to indexeddb. Error: ${e}`)\n    );\n    // Not using logger because I don't think we ever want this accidentally hidden?\n    console.log(\n      `AppCheck debug token: ${newToken}. You will need to whitelist it in the Firebase console for it to work`\n    );\n    return newToken;\n  } else {\n    return existingDebugToken;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getDebugState } from './state';\nimport { readOrCreateDebugTokenFromStorage } from './storage';\nimport { Deferred, getGlobal } from '@firebase/util';\n\ndeclare global {\n  // var must be used for global scopes\n  // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#type-checking-for-globalthis\n  // eslint-disable-next-line no-var\n  var FIREBASE_APPCHECK_DEBUG_TOKEN: boolean | string | undefined;\n}\n\nexport function isDebugMode(): boolean {\n  const debugState = getDebugState();\n  return debugState.enabled;\n}\n\nexport async function getDebugToken(): Promise<string> {\n  const state = getDebugState();\n\n  if (state.enabled && state.token) {\n    return state.token.promise;\n  } else {\n    // should not happen!\n    throw Error(`\n            Can't get debug token in production mode.\n        `);\n  }\n}\n\nexport function initializeDebugMode(): void {\n  const globals = getGlobal();\n  if (\n    typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' &&\n    globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true\n  ) {\n    return;\n  }\n\n  const debugState = getDebugState();\n  debugState.enabled = true;\n  const deferredToken = new Deferred<string>();\n  debugState.token = deferredToken;\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getToken as getReCAPTCHAToken } from './recaptcha';\nimport { FirebaseApp } from '@firebase/app-types';\nimport {\n  AppCheckTokenResult,\n  AppCheckTokenListener\n} from '@firebase/app-check-interop-types';\nimport {\n  AppCheckTokenInternal,\n  getDebugState,\n  getState,\n  setState\n} from './state';\nimport { TOKEN_REFRESH_TIME } from './constants';\nimport { Refresher } from './proactive-refresh';\nimport { ensureActivated } from './util';\nimport {\n  exchangeToken,\n  getExchangeDebugTokenRequest,\n  getExchangeRecaptchaTokenRequest\n} from './client';\nimport { writeTokenToStorage, readTokenFromStorage } from './storage';\nimport { getDebugToken, isDebugMode } from './debug';\nimport { base64, issuedAtTime } from '@firebase/util';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { logger } from './logger';\nimport { Provider } from '@firebase/component';\n\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\nexport const defaultTokenErrorData = { error: 'UNKNOWN_ERROR' };\n\n/**\n * Stringify and base64 encode token error data.\n *\n * @param tokenError Error data, currently hardcoded.\n */\nexport function formatDummyToken(\n  tokenErrorData: Record<string, string>\n): string {\n  return base64.encodeString(\n    JSON.stringify(tokenErrorData),\n    /* webSafe= */ false\n  );\n}\n\n/**\n * This function will always resolve.\n * The result will contain an error field if there is any error.\n * In case there is an error, the token field in the result will be populated with a dummy value\n */\nexport async function getToken(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>,\n  forceRefresh = false\n): Promise<AppCheckTokenResult> {\n  ensureActivated(app);\n  /**\n   * DEBUG MODE\n   * return the debug token directly\n   */\n  if (isDebugMode()) {\n    const tokenFromDebugExchange: AppCheckTokenInternal = await exchangeToken(\n      getExchangeDebugTokenRequest(app, await getDebugToken()),\n      platformLoggerProvider\n    );\n    return { token: tokenFromDebugExchange.token };\n  }\n\n  const state = getState(app);\n\n  let token: AppCheckTokenInternal | undefined = state.token;\n  let error: Error | undefined = undefined;\n\n  /**\n   * try to load token from indexedDB if it's the first time this function is called\n   */\n  if (!token) {\n    // readTokenFromStorage() always resolves. In case of an error, it resolves with `undefined`.\n    const cachedToken = await readTokenFromStorage(app);\n    if (cachedToken && isValid(cachedToken)) {\n      token = cachedToken;\n\n      setState(app, { ...state, token });\n      // notify all listeners with the cached token\n      notifyTokenListeners(app, { token: token.token });\n    }\n  }\n\n  // return the cached token if it's valid\n  if (!forceRefresh && token && isValid(token)) {\n    return {\n      token: token.token\n    };\n  }\n\n  /**\n   * request a new token\n   */\n  try {\n    if (state.customProvider) {\n      const customToken = await state.customProvider.getToken();\n      // Try to extract IAT from custom token, in case this token is not\n      // being newly issued. JWT timestamps are in seconds since epoch.\n      const issuedAtTimeSeconds = issuedAtTime(customToken.token);\n      // Very basic validation, use current timestamp as IAT if JWT\n      // has no `iat` field or value is out of bounds.\n      const issuedAtTimeMillis =\n        issuedAtTimeSeconds !== null &&\n        issuedAtTimeSeconds < Date.now() &&\n        issuedAtTimeSeconds > 0\n          ? issuedAtTimeSeconds * 1000\n          : Date.now();\n\n      token = { ...customToken, issuedAtTimeMillis };\n    } else {\n      const attestedClaimsToken = await getReCAPTCHAToken(app).catch(_e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(AppCheckError.RECAPTCHA_ERROR);\n      });\n      token = await exchangeToken(\n        getExchangeRecaptchaTokenRequest(app, attestedClaimsToken),\n        platformLoggerProvider\n      );\n    }\n  } catch (e) {\n    // `getToken()` should never throw, but logging error text to console will aid debugging.\n    logger.error(e);\n    error = e;\n  }\n\n  let interopTokenResult: AppCheckTokenResult | undefined;\n  if (!token) {\n    // if token is undefined, there must be an error.\n    // we return a dummy token along with the error\n    interopTokenResult = makeDummyTokenResult(error!);\n  } else {\n    interopTokenResult = {\n      token: token.token\n    };\n    // write the new token to the memory state as well ashe persistent storage.\n    // Only do it if we got a valid new token\n    setState(app, { ...state, token });\n    await writeTokenToStorage(app, token);\n  }\n\n  notifyTokenListeners(app, interopTokenResult);\n  return interopTokenResult;\n}\n\nexport function addTokenListener(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>,\n  listener: AppCheckTokenListener\n): void {\n  const state = getState(app);\n  const newState = {\n    ...state,\n    tokenListeners: [...state.tokenListeners, listener]\n  };\n\n  /**\n   * DEBUG MODE\n   *\n   * invoke the listener once with the debug token.\n   */\n  if (isDebugMode()) {\n    const debugState = getDebugState();\n    if (debugState.enabled && debugState.token) {\n      debugState.token.promise\n        .then(token => listener({ token }))\n        .catch(() => {\n          /* we don't care about exceptions thrown in listeners */\n        });\n    }\n  } else {\n    /**\n     * PROD MODE\n     *\n     * invoke the listener with the valid token, then start the token refresher\n     */\n    if (!newState.tokenRefresher) {\n      const tokenRefresher = createTokenRefresher(app, platformLoggerProvider);\n      newState.tokenRefresher = tokenRefresher;\n    }\n\n    // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n    // is not true.\n    if (\n      !newState.tokenRefresher.isRunning() &&\n      state.isTokenAutoRefreshEnabled === true\n    ) {\n      newState.tokenRefresher.start();\n    }\n\n    // invoke the listener async immediately if there is a valid token\n    if (state.token && isValid(state.token)) {\n      const validToken = state.token;\n      Promise.resolve()\n        .then(() => listener({ token: validToken.token }))\n        .catch(() => {\n          /* we don't care about exceptions thrown in listeners */\n        });\n    }\n  }\n\n  setState(app, newState);\n}\n\nexport function removeTokenListener(\n  app: FirebaseApp,\n  listener: AppCheckTokenListener\n): void {\n  const state = getState(app);\n\n  const newListeners = state.tokenListeners.filter(l => l !== listener);\n  if (\n    newListeners.length === 0 &&\n    state.tokenRefresher &&\n    state.tokenRefresher.isRunning()\n  ) {\n    state.tokenRefresher.stop();\n  }\n\n  setState(app, {\n    ...state,\n    tokenListeners: newListeners\n  });\n}\n\nfunction createTokenRefresher(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>\n): Refresher {\n  return new Refresher(\n    // Keep in mind when this fails for any reason other than the ones\n    // for which we should retry, it will effectively stop the proactive refresh.\n    async () => {\n      const state = getState(app);\n      // If there is no token, we will try to load it from storage and use it\n      // If there is a token, we force refresh it because we know it's going to expire soon\n      let result;\n      if (!state.token) {\n        result = await getToken(app, platformLoggerProvider);\n      } else {\n        result = await getToken(app, platformLoggerProvider, true);\n      }\n\n      // getToken() always resolves. In case the result has an error field defined, it means the operation failed, and we should retry.\n      if (result.error) {\n        throw result.error;\n      }\n    },\n    () => {\n      // TODO: when should we retry?\n      return true;\n    },\n    () => {\n      const state = getState(app);\n\n      if (state.token) {\n        // issuedAtTime + (50% * total TTL) + 5 minutes\n        let nextRefreshTimeMillis =\n          state.token.issuedAtTimeMillis +\n          (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) *\n            0.5 +\n          5 * 60 * 1000;\n        // Do not allow refresh time to be past (expireTime - 5 minutes)\n        const latestAllowableRefresh =\n          state.token.expireTimeMillis - 5 * 60 * 1000;\n        nextRefreshTimeMillis = Math.min(\n          nextRefreshTimeMillis,\n          latestAllowableRefresh\n        );\n        return Math.max(0, nextRefreshTimeMillis - Date.now());\n      } else {\n        return 0;\n      }\n    },\n    TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT,\n    TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT\n  );\n}\n\nfunction notifyTokenListeners(\n  app: FirebaseApp,\n  token: AppCheckTokenResult\n): void {\n  const listeners = getState(app).tokenListeners;\n\n  for (const listener of listeners) {\n    try {\n      listener(token);\n    } catch (e) {\n      // If any handler fails, ignore and run next handler.\n    }\n  }\n}\n\nfunction isValid(token: AppCheckTokenInternal): boolean {\n  return token.expireTimeMillis - Date.now() > 0;\n}\n\nfunction makeDummyTokenResult(error: Error): AppCheckTokenResult {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseAppCheck, AppCheckProvider } from '@firebase/app-check-types';\nimport { activate, setTokenAutoRefreshEnabled } from './api';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { FirebaseAppCheckInternal } from '@firebase/app-check-interop-types';\nimport {\n  getToken,\n  addTokenListener,\n  removeTokenListener\n} from './internal-api';\nimport { Provider } from '@firebase/component';\n\nexport function factory(app: FirebaseApp): FirebaseAppCheck {\n  return {\n    activate: (\n      siteKeyOrProvider: string | AppCheckProvider,\n      isTokenAutoRefreshEnabled?: boolean\n    ) => activate(app, siteKeyOrProvider, isTokenAutoRefreshEnabled),\n    setTokenAutoRefreshEnabled: (isTokenAutoRefreshEnabled: boolean) =>\n      setTokenAutoRefreshEnabled(app, isTokenAutoRefreshEnabled)\n  };\n}\n\nexport function internalFactory(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>\n): FirebaseAppCheckInternal {\n  return {\n    getToken: forceRefresh =>\n      getToken(app, platformLoggerProvider, forceRefresh),\n    addTokenListener: listener =>\n      addTokenListener(app, platformLoggerProvider, listener),\n    removeTokenListener: listener => removeTokenListener(app, listener)\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport firebase from '@firebase/app';\nimport { _FirebaseNamespace } from '@firebase/app-types/private';\nimport {\n  Component,\n  ComponentType,\n  InstantiationMode\n} from '@firebase/component';\nimport {\n  FirebaseAppCheck,\n  AppCheckComponentName\n} from '@firebase/app-check-types';\nimport { factory, internalFactory } from './factory';\nimport { initializeDebugMode } from './debug';\nimport { AppCheckInternalComponentName } from '@firebase/app-check-interop-types';\nimport { name, version } from '../package.json';\n\nconst APP_CHECK_NAME: AppCheckComponentName = 'appCheck';\nconst APP_CHECK_NAME_INTERNAL: AppCheckInternalComponentName =\n  'app-check-internal';\nfunction registerAppCheck(firebase: _FirebaseNamespace): void {\n  // The public interface\n  firebase.INTERNAL.registerComponent(\n    new Component(\n      APP_CHECK_NAME,\n      container => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        return factory(app);\n      },\n      ComponentType.PUBLIC\n    )\n      /**\n       * AppCheck can only be initialized by explicitly calling firebase.appCheck()\n       * We don't want firebase products that consume AppCheck to gate on AppCheck\n       * if the user doesn't intend them to, just because the AppCheck component\n       * is registered.\n       */\n      .setInstantiationMode(InstantiationMode.EXPLICIT)\n      /**\n       * Because all firebase products that depend on app-check depend on app-check-internal directly,\n       * we need to initialize app-check-internal after app-check is initialized to make it\n       * available to other firebase products.\n       */\n      .setInstanceCreatedCallback(\n        (container, _instanceIdentifier, _instance) => {\n          const appCheckInternalProvider = container.getProvider(\n            APP_CHECK_NAME_INTERNAL\n          );\n          appCheckInternalProvider.initialize();\n        }\n      )\n  );\n\n  // The internal interface used by other Firebase products\n  firebase.INTERNAL.registerComponent(\n    new Component(\n      APP_CHECK_NAME_INTERNAL,\n      container => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        const platformLoggerProvider = container.getProvider('platform-logger');\n        return internalFactory(app, platformLoggerProvider);\n      },\n      ComponentType.PUBLIC\n    ).setInstantiationMode(InstantiationMode.EXPLICIT)\n  );\n\n  firebase.registerVersion(name, version);\n}\n\nregisterAppCheck(firebase as _FirebaseNamespace);\ninitializeDebugMode();\n\n/**\n * Define extension behavior of `registerAnalytics`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    appCheck(app?: FirebaseApp): FirebaseAppCheck;\n  }\n  interface FirebaseApp {\n    appCheck(): FirebaseAppCheck;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}